<!DOCTYPE html><html class="2xl:text-[20px]" dir="ltr" lang="zh"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1" name="viewport"><title>深入理解K8s资源限制</title><meta content="index,follow" name="robots"/><meta content="深入理解K8s资源限制" property="og:title"/><meta content="https://qingwave.github.io/understanding-resource-limits-in-kubernetes" property="og:url"/><meta content="article" property="og:type"/><link href="https://qingwave.github.io/understanding-resource-limits-in-kubernetes" rel="canonical"/><style is:global>:root{--aw-font-sans:'InterVariable';--aw-font-serif:var(--aw-font-sans);--aw-font-heading:var(--aw-font-sans);--aw-color-primary:#10b981;--aw-color-secondary:rgb(30 58 138);--aw-color-accent:rgb(109 40 217);--aw-color-text-page:rgb(17 24 39);--aw-color-text-muted:rgb(75 85 99);--aw-color-bg-page:rgb(255 255 255)}</style><meta content="-8bOgP-V4XsxXZtXVx9DIXkdIuruvAYiY37vBg26acI" name="google-site-verification"><script src="https://www.googletagmanager.com/gtag/js?id=UA-134548083-1" async type="text/partytown"></script><script type="text/partytown">(function(){const id = "UA-134548083-1";

  window.dataLayer = window.dataLayer || [];
  function gtag() {
    window.dataLayer.push(arguments);
  }
  gtag("js", new Date());
  gtag("config", id);
})();</script><link href="/favicon.ico" rel="shortcut icon"><link href="/favicon.svg" rel="icon" type="image/svg+xml"><link href="/favicon.svg" rel="mask-icon" color="#8D46E7"><link href="/sitemap-index.xml" rel="sitemap"><link href="/_astro/_...page_.0ba5b97b.css" rel="stylesheet"/><script src="/_astro/hoisted.fa5a2e6c.js" type="module"></script><script>!function(t,e,n,i){(i=t[e]=Object.assign(t[e]||{},{lib:"/~partytown/",debug:!1}))[n]=(i[n]||[]).concat(["dataLayer.push"])}(window,"partytown","forward"),function(t,e,n,i,a,o,r,d,s,c,p,l){function u(){l||(l=1,"/"==(r=(o.lib||"/~partytown/")+(o.debug?"debug/":""))[0]&&(s=e.querySelectorAll('script[type="text/partytown"]'),i!=t?i.dispatchEvent(new CustomEvent("pt1",{detail:t})):(d=setTimeout(f,1e4),e.addEventListener("pt0",h),a?w(1):n.serviceWorker?n.serviceWorker.register(r+(o.swPath||"partytown-sw.js"),{scope:r}).then((function(t){t.active?w():t.installing&&t.installing.addEventListener("statechange",(function(t){"activated"==t.target.state&&w()}))}),console.error):f())))}function w(t){c=e.createElement(t?"script":"iframe"),t||(c.setAttribute("style","display:block;width:0;height:0;border:0;visibility:hidden"),c.setAttribute("aria-hidden",!0)),c.src=r+"partytown-"+(t?"atomics.js?v=0.7.6":"sandbox-sw.html?"+Date.now()),e.body.appendChild(c)}function f(n,a){for(h(),i==t&&(o.forward||[]).map((function(e){delete t[e.split(".")[0]]})),n=0;n<s.length;n++)(a=e.createElement("script")).innerHTML=s[n].innerHTML,e.head.appendChild(a);c&&c.parentNode.removeChild(c)}function h(){clearTimeout(d)}o=t.partytown||{},i==t&&(o.forward||[]).map((function(e){p=t,e.split(".").map((function(e,n,i){p=p[i[n]]=n+1<i.length?"push"==i[n+1]?[]:p[i[n]]||{}:function(){(t._ptf=t._ptf||[]).push(i,arguments)}}))})),"complete"==e.readyState?u():(t.addEventListener("DOMContentLoaded",u),t.addEventListener("load",u))}(window,document,navigator,top,window.crossOriginIsolated)</script></head><body class="dark:text-slate-300 antialiased bg-light dark:bg-dark text-page tracking-tight"><header class="md:py-8 flex-none mt-8 py-4 sticky top-0 w-full z-40" id="header"><div class="max-w-3xl mx-auto sm:px-6 px-6 md:flex md:justify-between"><div class="items-center md:flex"><div class="flex justify-between"><a href="/" class="items-center flex"><img class="h-6 w-6 dark:invert invert-0" src="/favicon.svg"></a><div class="items-center flex md:hidden"><button aria-label="Toggle between Dark and Light mode" class="items-center dark:text-gray-400 inline-flex p-2.5 text-sm dark:hover:text-slate-300 hover:text-slate-950 text-slate-800" type="button" data-aw-toggle-color-scheme><svg astro-icon="ph:moon-fill" class="h-8 w-8" viewBox="0 0 256 256"><path d="M224.3 154.9A100 100 0 1 1 101 31.7a7.9 7.9 0 0 1 10.3 8.1 5.7 5.7 0 0 1-.3 1.8A84 84 0 0 0 214.3 145l2.2-.4a8.1 8.1 0 0 1 7.8 5.7 7.2 7.2 0 0 1 0 4.6z" fill="currentColor"/></svg></button> <button aria-label="Toggle Menu" class="items-center dark:text-gray-400 inline-flex p-2.5 text-sm dark:focus:ring-gray-700 dark:hover:bg-gray-800 focus:outline-none focus:ring-4 focus:ring-gray-200 hover:bg-gray-100 ml-1.5 rounded-lg text-gray-500 transition" type="button" data-aw-toggle-menu><svg astro-icon="tabler:menu" class="h-6 w-6" viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><g class="icon-tabler" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M4 8h16"/><path d="M4 16h16"/></g></svg></button></div></div><nav aria-label="Main navigation" class="items-center md:flex hidden dark:text-slate-200 h-[calc(100vh-72px)] md:h-auto md:mx-5 md:overflow-visible md:w-auto overflow-y-auto pr-4 w-full"><ul class="flex flex-col md:flex-row md:pt-0 md:self-center md:text-base md:w-auto pt-8 text-xl w-full"><li class=""><a href="/blog" class="items-center flex dark:hover:text-white hover:text-gray-900 px-4 py-3" memu-item>写作</a></li><li class=""><a href="/project" class="items-center flex dark:hover:text-white hover:text-gray-900 px-4 py-3" memu-item>项目</a></li><li class=""><a href="/tags" class="items-center flex dark:hover:text-white hover:text-gray-900 px-4 py-3" memu-item>标签</a></li><li class=""><a href="/about" class="items-center flex dark:hover:text-white hover:text-gray-900 px-4 py-3" memu-item>关于我</a></li></ul></nav></div><div class="items-center flex md:mb-0 md:self-center"><div class="items-center md:flex hidden"><button aria-label="Toggle between Dark and Light mode" class="items-center dark:text-gray-400 inline-flex p-2.5 text-sm dark:hover:text-slate-300 hover:text-slate-950 text-slate-800" type="button" data-aw-toggle-color-scheme><svg astro-icon="ph:moon-fill" class="h-6 w-6" viewBox="0 0 256 256"><path d="M224.3 154.9A100 100 0 1 1 101 31.7a7.9 7.9 0 0 1 10.3 8.1 5.7 5.7 0 0 1-.3 1.8A84 84 0 0 0 214.3 145l2.2-.4a8.1 8.1 0 0 1 7.8 5.7 7.2 7.2 0 0 1 0 4.6z" fill="currentColor"/></svg></button></div></div></div></header><main><section class="max-w-3xl mx-auto lg:py-20 py-8 sm:py-16"><article><header class=""><div class="flex px-4 flex-col justify-between max-w-3xl mb-2 mt-0 mx-auto sm:flex-row sm:items-center sm:px-6"><p class="text-sm dark:text-slate-400 leading-6 text-slatey-700"><time datetime="Wed Jan 09 2019 16:34:33 GMT+0000 (Coordinated Universal Time)">Jan 9, 2019</time> · <a href="/categories/cloud" class="capitalize hover:underline">cloud</a></p></div><h1 class="max-w-3xl mx-auto sm:px-6 px-4 font-bold font-heading leading-tighter md:text-5xl text-4xl tracking-tighter">深入理解K8s资源限制</h1><p class="max-w-3xl mx-auto sm:px-6 px-4 dark:text-slate-400 mb-8 md:text-2xl mt-4 text-justify text-muted text-xl"></p><div class="max-w-3xl mx-auto sm:px-6 px-4"><div class="border-t dark:border-slate-700"></div></div></header><div class="max-w-3xl mx-auto sm:px-6 px-6 mt-8 break-words dark:prose-a:text-blue-400 dark:prose-headings:text-slate-300 dark:prose-invert lg:prose-xl overflow-x-hidden prose prose-a:text-primary prose-headings:font-bold prose-headings:font-heading prose-headings:leading-tighter prose-headings:tracking-tighter prose-img:rounded-md prose-img:shadow-lg prose-lg prose-md"><div class="table-wrap"><blockquote><p>本文翻译自<a href="https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-memory-6b41e9a955f9">understanding-resource-limits-in-kubernetes-memory</a></p></blockquote><h2 id="写在前面">写在前面</h2><p>当我开始大范围使用 Kubernetes 的时候，我开始考虑一个我做实验时没有遇到的问题：当集群里的节点没有足够资源的时候，Pod 会卡在<code>Pending</code>状态。你是没有办法给节点增加 CPU 或者内存的，那么你该怎么做才能将这个 Pod 从这个节点拿走？</p><p>最简单的办法是添加另一个节点。但是这个策略无法发挥出 Kubernetes 最重要的一个能力：即它优化计算资源使用的能力。这些场景里面实际的问题并不是节点太小，而是我们没有仔细为 Pod 计算过资源限制。</p><p>资源限制是我们可以向 Kubernetes 提供的诸多配置之一，它意味着两点：</p><ul><li>工作负载运行需要哪些资源</li><li>最多允许消费多少资源</li></ul><p>第一点对于调度器而言十分重要，因为它要以此选择合适的节点。第二点对于 Kubelet 非常重要，每个节点上的守护进程 Kubelet 负责 Pod 的运行健康状态。</p><p>大多数本文的读者可能对资源限制有一定的了解，实际上这里面有很多有趣的细节。</p><h2 id="资源限制">资源限制</h2><p>资源限制是通过每个容器 containerSpec 的 resources 字段进行设置的，它是 v1 版本的 ResourceRequirements 类型的 API 对象。每个指定了”limits”和”requests”的对象都可以控制对应的资源。</p><p>目前只有 CPU 和内存两种资源。大多数情况下，deployment、statefulset、daemonset 的定义里都包含了 podSpec 和多个 containerSpec。这里有个完整的 v1 资源对象的 yaml 格式配置：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#8be9fd">resources</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#8be9fd">requests</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">cpu</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">50m</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">memory</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">50Mi</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#8be9fd">limits</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">cpu</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">100m</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">memory</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">100Mi</span></span></code></pre><p>这个对象可以这么理解：这个容器通常情况下，需要 5%的 CPU 时间和 50MiB 的内存（requests），同时最多允许它使用 10%的 CPU 时间和 100MiB 的内存（limits）。</p><p>我会对<code>requests</code>和<code>limits</code>的区别做进一步讲解，但是一般来说，在调度的时候<code>requests</code>比较重要，在运行时<code>limits</code>比较重要。尽管资源限制配置在每个容器上，你可以认为 Pod 的资源限制就是它里面容器的资源限制之和，我们可以从系统的视角观察到这种关系。</p><h3 id="内存限制">内存限制</h3><p>通常情况下分析内存要比分析 CPU 简单一些，所以我从这里开始着手。我的一个目标是给大家展示内存在系统中是如何实现的，也就是 Kubernetes 对容器运行时（docker/containerd）所做的工作，容器运行时对 Linux 内核所做的工作。从分析内存资源限制开始也为后面分析 CPU 打好了基础。</p><p>首先，让我们回顾一下前面的例子：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#8be9fd">resources</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#8be9fd">requests</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#8be9fd">memory</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">50Mi</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#8be9fd">limits</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#8be9fd">memory</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">100Mi</span></span></code></pre><p>单位后缀 Mi 表示的是 MiB，所以这个资源对象定义了这个容器需要 50MiB 并且最多能使用 100MiB 的内存。当然还有其他单位可以进行表示。</p><p>为了了解如何用这些值是来控制容器进程，我们来创建一个没有配置内存限制的 Pod:</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">kubectl</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">run</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">limit-test</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--image=busybox</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--command</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/bin/sh</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-c</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">while true; do sleep 2; done</span><span style="color:#e9f284">"</span></span>
<span class="line"><span style="color:#50fa7b">deployment.apps</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">limit-test</span><span style="color:#e9f284">"</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">created</span></span></code></pre><p>用 Kubectl 命令我们可以验证这个 Pod 是没有资源限制的：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">kubectl</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">get</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">pods</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">limit-test-7cff9996fc-zpjps</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-o=jsonpath=</span><span style="color:#e9f284">'</span><span style="color:#f1fa8c">{.spec.containers[0].resources}</span><span style="color:#e9f284">'</span></span>
<span class="line"><span style="color:#50fa7b">map[]</span></span></code></pre><p>Kubernetes 最酷的一点是你可以跳到系统以外的角度来观察每个构成部分，所以我们登录到运行 Pod 的节点，看看 Docker 是如何运行这个容器的：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">docker</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">ps</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">|</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">grep</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">busy</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">|</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">cut</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-d</span><span style="color:#e9f284">'</span><span style="color:#f1fa8c"> </span><span style="color:#e9f284">'</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-f1</span></span>
<span class="line"><span style="color:#50fa7b">5c3af3101afb</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">docker</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">inspect</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">5</span><span style="color:#f1fa8c">c3af3101afb</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-f</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">{{.HostConfig.Memory}}</span><span style="color:#e9f284">"</span></span>
<span class="line"><span style="color:#50fa7b">0</span></span></code></pre><p>这个容器的<code>.HostConfig.Memory</code>域对应了 docker run 时的<code>--memory</code>参数，0 值表示未设定。Docker 会对这个值做什么？为了控制容器进程能够访问的内存数量，Docker 配置了一组 control group，或者叫 cgroup。</p><blockquote><p>Cgroup 在 2008 年 1 月时合并到 Linux 2.6.24 版本的内核。它是一个很重要的话题。我们说 cgroup 是容器的一组用来控制内核如何运行进程的相关属性集合。针对内存、CPU 和各种设备都有对应的 cgroup。Cgroup 是具有层级的，这意味着每个 cgroup 拥有一个它可以继承属性的父亲，往上一直直到系统启动时创建的 root cgroup。</p></blockquote><p>Cgroup 可以通过/proc 和/sys 伪文件系统轻松查看到，所以检查容器如何配置内存的 cgroup 就很简单了。在容器的 Pid namespace 里，根进程的 pid 为 1，但是 namespace 以外它呈现的是系统级 pid，我们可以用来查找它的 cgroups：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">ps</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">ax</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">|</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">grep</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/bin/sh</span></span>
<span class="line"><span style="color:#f8f8f2">   </span><span style="color:#50fa7b">9513</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">?</span><span style="color:#f8f8f2">        </span><span style="color:#f1fa8c">Ss</span><span style="color:#f8f8f2">     </span><span style="color:#bd93f9">0</span><span style="color:#f1fa8c">:00</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/bin/sh</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-c</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">while</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">true</span><span style="color:#f8f8f2">; </span><span style="color:#ff79c6">do</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">sleep</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">2</span><span style="color:#f8f8f2">; </span><span style="color:#ff79c6">done</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">sudo</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cat</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/proc/9513/cgroup</span></span>
<span class="line"><span style="color:#8be9fd">...</span></span>
<span class="line"><span style="color:#50fa7b">6:memory:/kubepods/burstable/podfbc202d3-da21-11e8-ab5e-42010a80014b/0a1b22ec1361a97c3511db37a4bae932d41b22264e5b97611748f8b662312574</span></span></code></pre><p>我列出了内存 cgroup，这正是我们所关注的。你在路径里可以看到前面提到的 cgroup 层级。一些比较重要的点是：</p><p>首先，这个路径是以 kubepods 开始的 cgroup，所以我们的进程继承了这个 group 的每个属性，还有 burstable 的属性（Kubernetes 将 Pod 设置为<code>burstable QoS</code>类别）和一组用于审计的 Pod 表示。</p><p>最后一段路径是我们进程实际使用的 cgroup。我们可以把它追加到<code>/sys/fs/cgroups/memory</code>后面查看更多信息：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">ls</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-l</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/sys/fs/cgroup/memory/kubepods/burstable/podfbc202d3-da21-11e8-ab5e-42010a80014b/0a1b22ec1361a97c3511db37a4bae932d41b22264e5b97611748f8b662312574</span></span>
<span class="line"><span style="color:#8be9fd">...</span></span>
<span class="line"><span style="color:#50fa7b">-rw-r--r--</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">1</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">root</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">root</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">0</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">Oct</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">27</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">19</span><span style="color:#f1fa8c">:53</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">memory.limit_in_bytes</span></span>
<span class="line"><span style="color:#50fa7b">-rw-r--r--</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">1</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">root</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">root</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">0</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">Oct</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">27</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">19</span><span style="color:#f1fa8c">:53</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">memory.soft_limit_in_bytes</span></span></code></pre><p>再一次，我只列出了我们所关心的记录。我们暂时不关注<code>memory.soft_limit_in_bytes</code>，而将重点转移到<code>memory.limit_in_bytes</code>属性，它设置了内存限制。它等价于 Docker 命令中的<code>--memory</code>参数，也就是 Kubernetes 里的内存资源限制。我们看看：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">sudo</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cat</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/sys/fs/cgroup/memory/kubepods/burstable/podfbc202d3-da21-11e8-ab5e-42010a80014b/0a1b22ec1361a97c3511db37a4bae932d41b22264e5b97611748f8b662312574/memory.limit_in_bytes</span></span>
<span class="line"><span style="color:#50fa7b">9223372036854771712</span></span></code></pre><p>这是没有设置资源限制时我的节点上显示的情况。这里有对它的一个简单的<a href="https://unix.stackexchange.com/questions/420906/what-is-the-value-for-the-cgroups-limit-in-bytes-if-the-memory-is-not-restricte">解释</a>。 所以我们看到如果没有在 Kubernetes 里设置内存限制的话，会导致 Docker 设置<code>HostConfig.Memory</code>值为 0，并进一步导致容器进程被放置在默认值为”no limit”的<code>memory.limit_in_bytes</code>内存 cgroup 下。</p><p>我们现在创建使用 100MiB 内存限制的 Pod：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">kubectl</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">run</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">limit-test</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--image=busybox</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--limits</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">memory=100Mi</span><span style="color:#e9f284">"</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--command</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/bin/sh</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-c</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">while true; do sleep 2; done</span><span style="color:#e9f284">"</span></span>
<span class="line"><span style="color:#50fa7b">deployment.apps</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">limit-test</span><span style="color:#e9f284">"</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">created</span></span></code></pre><p>我们再一次使用 kubectl 验证我们的资源配置：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">kubectl</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">get</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">pods</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">limit-test-5f5c7dc87d-8qtdx</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-o=jsonpath=</span><span style="color:#e9f284">'</span><span style="color:#f1fa8c">{.spec.containers[0].resources}</span><span style="color:#e9f284">'</span></span>
<span class="line"><span style="color:#50fa7b">map[limits:map[memory:100Mi]</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">requests:map[memory:100Mi]]</span></span></code></pre><p>你会注意到除了我们设置的<code>limits</code>外，Pod 还增加了 requests。当你设置<code>limits</code>而没有设置<code>requests</code>时，Kubernetes 默认让<code>requests</code>等于 limits。如果你从调度器的角度看这是非常有意义的。我会在下面进一步讨论 requests。当这个 Pod 启动后，我们可以看到 Docker 如何配置的容器以及这个进程的内存 cgroup：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">docker</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">ps</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">|</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">grep</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">busy</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">|</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">cut</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-d</span><span style="color:#e9f284">'</span><span style="color:#f1fa8c"> </span><span style="color:#e9f284">'</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-f1</span></span>
<span class="line"><span style="color:#50fa7b">8fec6c7b6119</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">docker</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">inspect</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">8</span><span style="color:#f1fa8c">fec6c7b6119</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--format</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">'</span><span style="color:#f1fa8c">{{.HostConfig.Memory}}</span><span style="color:#e9f284">'</span></span>
<span class="line"><span style="color:#50fa7b">104857600</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">ps</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">ax</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">|</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">grep</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/bin/sh</span></span>
<span class="line"><span style="color:#f8f8f2">   </span><span style="color:#50fa7b">29532</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">?</span><span style="color:#f8f8f2">      </span><span style="color:#f1fa8c">Ss</span><span style="color:#f8f8f2">     </span><span style="color:#bd93f9">0</span><span style="color:#f1fa8c">:00</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/bin/sh</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-c</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">while</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">true</span><span style="color:#f8f8f2">; </span><span style="color:#ff79c6">do</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">sleep</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">2</span><span style="color:#f8f8f2">; </span><span style="color:#ff79c6">done</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">sudo</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cat</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/proc/29532/cgroup</span></span>
<span class="line"><span style="color:#8be9fd">...</span></span>
<span class="line"><span style="color:#50fa7b">6:memory:/kubepods/burstable/pod88f89108-daf7-11e8-b1e1-42010a800070/8fec6c7b61190e74cd9f88286181dd5fa3bbf9cf33c947574eb61462bc254d11</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">sudo</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cat</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/sys/fs/cgroup/memory/kubepods/burstable/pod88f89108-daf7-11e8-b1e1-42010a800070/8fec6c7b61190e74cd9f88286181dd5fa3bbf9cf33c947574eb61462bc254d11/memory.limit_in_bytes</span></span>
<span class="line"><span style="color:#50fa7b">104857600</span></span></code></pre><p>正如你所见，Docker 基于我们的 containerSpec 正确地设置了这个进程的内存 cgroup。但是这对于运行时意味着什么？Linux 内存管理是一个复杂的话题，Kubernetes 工程师需要知道的是：当一个宿主机遇到了内存资源压力时，内核可能会有选择性地杀死进程。</p><p>如果一个使用了多于限制内存的进程会有更高几率被杀死。因为 Kubernetes 的任务是尽可能多地向这些节点上安排 Pod，这会导致节点内存压力异常。如果你的容器使用了过多内存，那么它很可能会被 oom-killed。如果 Docker 收到了内核的通知，Kubernetes 会找到这个容器并依据设置尝试重启这个 Pod。</p><p>所以 Kubernetes 默认创建的内存<code>requests</code>是什么？拥有一个 100MiB 的内存请求会影响到 cgroup？可能它设置了我们之前看到的<code>memory.soft_limit_in_bytes</code>？让我们看看：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">sudo</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cat</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/sys/fs/cgroup/memory/kubepods/burstable/pod88f89108-daf7-11e8-b1e1-42010a800070/8fec6c7b61190e74cd9f88286181dd5fa3bbf9cf33c947574eb61462bc254d11/memory.soft_limit_in_bytes</span></span>
<span class="line"><span style="color:#50fa7b">9223372036854771712</span></span></code></pre><p>你可以看到软限制仍然被设置为默认值“no limit”。即使 Docker 支持通过参数<code>--memory-reservation</code>进行设置，但 Kubernetes 并不支持这个参数。这是否意味着为你的容器指定内存<code>requests</code>并不重要？不，不是的。<code>requests</code>要比<code>limits</code>更重要。limits 告诉 Linux 内核什么时候你的进程可以为了清理空间而被杀死。<code>requests</code>帮助 Kubernetes 调度找到合适的节点运行 Pod。如果不设置它们，或者设置得非常低，那么可能会有不好的影响。</p><p>例如，假设你没有配置内存<code>requests</code>来运行 Pod，而配置了一个较高的 limits。正如我们所知道的 Kubernetes 默认会把<code>requests</code>的值指向 limits，如果没有合适的资源的节点的话，Pod 可能会调度失败，即使它实际需要的资源并没有那么多。</p><p>另一方面，如果你运行了一个配置了较低<code>requests</code>值的 Pod，你其实是在鼓励内核 oom-kill 掉它。为什么？假设你的 Pod 通常使用 100MiB 内存，你却只为它配置了 50MiB 内存 requests。如果你有一个拥有 75MiB 内存空间的节点，那么这个 Pod 会被调度到这个节点。当 Pod 内存消耗扩大到 100MiB 时，会让这个节点压力变大，这个时候内核可能会选择杀掉你的进程。所以我们要正确配置 Pod 的内存<code>requests</code>和 limits。</p><h3 id="cpu-限制">CPU 限制</h3><p>CPU 资源限制比内存资源限制更复杂，原因将在下文详述。幸运的是 CPU 资源限制和内存资源限制一样都是由 cgroup 控制的，上文中提到的思路和工具在这里同样适用，我们只需要关注他们的不同点就行了。</p><p>首先，让我们将 CPU 资源限制添加到之前示例中的 yaml：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#8be9fd">resources</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#8be9fd">requests</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#8be9fd">memory</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">50Mi</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#8be9fd">cpu</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">50m</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#8be9fd">limits</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#8be9fd">memory</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">100Mi</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#8be9fd">cpu</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">100m</span></span></code></pre><p>单位后缀 m 表示千分之一核，也就是说 1 Core = 1000m。因此该资源对象指定容器进程需要 50/1000 核（5%）才能被调度，并且允许最多使用 100/1000 核（10%）。同样，2000m 表示两个完整的 CPU 核心，你也可以写成 2 或者 2.0。</p><p>为了了解 Docker 和 cgroup 如何使用这些值来控制容器，我们首先创建一个只配置了 CPU<code>requests</code>的 Pod：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">kubectl</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">run</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">limit-test</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--image=busybox</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--requests</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">cpu=50m</span><span style="color:#e9f284">"</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--command</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/bin/sh</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-c</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">while true; do sleep 2; done</span><span style="color:#e9f284">"</span></span>
<span class="line"><span style="color:#50fa7b">deployment.apps</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">limit-test</span><span style="color:#e9f284">"</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">created</span></span></code></pre><p>通过 kubectl 命令我们可以验证这个 Pod 配置了 50m 的 CPU requests：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">kubectl</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">get</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">pods</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">limit-test-5b4c495556-p2xkr</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-o=jsonpath=</span><span style="color:#e9f284">'</span><span style="color:#f1fa8c">{.spec.containers[0].resources}</span><span style="color:#e9f284">'</span></span>
<span class="line"><span style="color:#50fa7b">map[requests:map[cpu:50m]]</span></span></code></pre><p>我们还可以看到 Docker 为容器配置了相同的资源限制：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">docker</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">ps</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">|</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">grep</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">busy</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">|</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">cut</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-d</span><span style="color:#e9f284">'</span><span style="color:#f1fa8c"> </span><span style="color:#e9f284">'</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-f1</span></span>
<span class="line"><span style="color:#50fa7b">f2321226620e</span></span>
<span class="line"></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">docker</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">inspect</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">f2321226620e</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--format</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">'</span><span style="color:#f1fa8c">{{.HostConfig.CpuShares}}</span><span style="color:#e9f284">'</span></span>
<span class="line"><span style="color:#50fa7b">51</span></span></code></pre><p>这里显示的为什么是 51，而不是 50？这是因为 Linux cgroup 和 Docker 都将 CPU 核心数分成了 1024 个时间片（shares），而 Kubernetes 将它分成了 1000 个<code>shares</code>。</p><p><code>shares</code>用来设置 CPU 的相对值，并且是针对所有的 CPU（内核），默认值是 1024，假如系统中有两个 cgroup，分别是 A 和 B，A 的<code>shares</code>值是 1024，B 的<code>shares</code>值是 512，那么 A 将获得 1024/(1204+512)=66% 的 CPU 资源，而 B 将获得 33% 的 CPU 资源。</p><p><code>shares</code>有两个特点：</p><ol><li>如果 A 不忙，没有使用到 66% 的 CPU 时间，那么剩余的 CPU 时间将会被系统分配给 B，即 B 的 CPU 使用率可以超过 33%。</li><li>如果添加了一个新的 cgroup C，且它的<code>shares</code>值是 1024，那么 A 的限额变成了 1024/(1204+512+1024)=40%，B 的变成了 20%。</li></ol><p>从上面两个特点可以看出：</p><ul><li>在闲的时候，shares 基本上不起作用，只有在 CPU 忙的时候起作用，这是一个优点。</li><li>由于<code>shares</code>是一个绝对值，需要和其它 cgroup 的值进行比较才能得到自己的相对限额，而在一个部署很多容器的机器上，cgroup 的数量是变化的，所以这个限额也是变化的，自己设置了一个高的值，但别人可能设置了一个更高的值，所以这个功能没法精确的控制 CPU 使用率。</li></ul><p>与配置内存资源限制时 Docker 配置容器进程的内存 cgroup 的方式相同，设置 CPU 资源限制时 Docker 会配置容器进程的 cpu,cpuacct cgroup：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">ps</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">ax</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">|</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">grep</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/bin/sh</span></span>
<span class="line"><span style="color:#f8f8f2">   </span><span style="color:#50fa7b">60554</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">?</span><span style="color:#f8f8f2">      </span><span style="color:#f1fa8c">Ss</span><span style="color:#f8f8f2">     </span><span style="color:#bd93f9">0</span><span style="color:#f1fa8c">:00</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/bin/sh</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-c</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">while</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">true</span><span style="color:#f8f8f2">; </span><span style="color:#ff79c6">do</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">sleep</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">2</span><span style="color:#f8f8f2">; </span><span style="color:#ff79c6">done</span></span>
<span class="line"></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">sudo</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cat</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/proc/60554/cgroup</span></span>
<span class="line"><span style="color:#8be9fd">...</span></span>
<span class="line"><span style="color:#50fa7b">4:cpu,cpuacct:/kubepods/burstable/pode12b33b1-db07-11e8-b1e1-42010a800070/3be263e7a8372b12d2f8f8f9b4251f110b79c2a3bb9e6857b2f1473e640e8e75</span></span>
<span class="line"></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">ls</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-l</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pode12b33b1-db07-11e8-b1e1-42010a800070/3be263e7a8372b12d2f8f8f9b4251f110b79c2a3bb9e6857b2f1473e640e8e75</span></span>
<span class="line"><span style="color:#50fa7b">total</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">0</span></span>
<span class="line"><span style="color:#50fa7b">drwxr-xr-x</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">2</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">root</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">root</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">0</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">Oct</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">28</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">23</span><span style="color:#f1fa8c">:19</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">.</span></span>
<span class="line"><span style="color:#50fa7b">drwxr-xr-x</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">4</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">root</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">root</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">0</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">Oct</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">28</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">23</span><span style="color:#f1fa8c">:19</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">..</span></span>
<span class="line"><span style="color:#8be9fd">...</span></span>
<span class="line"><span style="color:#50fa7b">-rw-r--r--</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">1</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">root</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">root</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">0</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">Oct</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">28</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">23</span><span style="color:#f1fa8c">:19</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cpu.shares</span></span></code></pre><p>Docker 容器的 HostConfig.CpuShares 属性映射到 cgroup 的 cpu.shares 属性，可以验证一下：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">sudo</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cat</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/podb5c03ddf-db10-11e8-b1e1-42010a800070/64b5f1b636dafe6635ddd321c5b36854a8add51931c7117025a694281fb11444/cpu.shares</span></span>
<span class="line"><span style="color:#50fa7b">51</span></span></code></pre><p>你可能会很惊讶，设置了 CPU<code>requests</code>竟然会把值传播到 cgroup，而在设置内存<code>requests</code>时并没有将值传播到 cgroup。这是因为内存的 soft limit 内核特性对 Kubernetes 不起作用，而设置了 cpu.shares 却对 Kubernetes 很有用。后面我会详细讨论为什么会这样。现在让我们先看看设置 CPU<code>limits</code>时会发生什么：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">kubectl</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">run</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">limit-test</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--image=busybox</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--requests</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">cpu=50m</span><span style="color:#e9f284">"</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--limits</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">cpu=100m</span><span style="color:#e9f284">"</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--command</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/bin/sh</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-c</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">while true; do</span></span>
<span class="line"><span style="color:#f1fa8c">sleep 2; done</span><span style="color:#e9f284">"</span></span>
<span class="line"><span style="color:#50fa7b">deployment.apps</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">"</span><span style="color:#f1fa8c">limit-test</span><span style="color:#e9f284">"</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">created</span></span></code></pre><p>再一次使用 kubectl 验证我们的资源配置：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">kubectl</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">get</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">pods</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">limit-test-5b4fb64549-qpd4n</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-o=jsonpath=</span><span style="color:#e9f284">'</span><span style="color:#f1fa8c">{.spec.containers[0].resources}</span><span style="color:#e9f284">'</span></span>
<span class="line"><span style="color:#50fa7b">map[limits:map[cpu:100m]</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">requests:map[cpu:50m]]</span></span></code></pre><p>查看对应的 Docker 容器的配置：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">docker</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">ps</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">|</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">grep</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">busy</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">|</span><span style="color:#f8f8f2"> </span><span style="color:#50fa7b">cut</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-d</span><span style="color:#e9f284">'</span><span style="color:#f1fa8c"> </span><span style="color:#e9f284">'</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">-f1</span></span>
<span class="line"><span style="color:#50fa7b">f2321226620e</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">docker</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">inspect</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">472</span><span style="color:#f1fa8c">abbce32a5</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">--format</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">'</span><span style="color:#f1fa8c">{{.HostConfig.CpuShares}} {{.HostConfig.CpuQuota}} {{.HostConfig.CpuPeriod}}</span><span style="color:#e9f284">'</span></span>
<span class="line"><span style="color:#50fa7b">51</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">10000</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">100000</span></span></code></pre><p>可以明显看出，CPU<code>requests</code>对应于 Docker 容器的 HostConfig.CpuShares 属性。而 CPU<code>limits</code>就不太明显了，它由两个属性控制：<code>HostConfig.CpuPeriod</code> 和 <code>HostConfig.CpuQuota</code>。</p><p>Docker 容器中的这两个属性又会映射到进程的 cpu,couacct cgroup 的另外两个属性：<code>cpu.cfs_period_us</code>和 <code>cpu.cfs_quota_us</code>：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">sudo</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cat</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pod2f1b50b6-db13-11e8-b1e1-42010a800070/f0845c65c3073e0b7b0b95ce0c1eb27f69d12b1fe2382b50096c4b59e78cdf71/cpu.cfs_period_us</span></span>
<span class="line"><span style="color:#50fa7b">100000</span></span>
<span class="line"></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">sudo</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cat</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pod2f1b50b6-db13-11e8-b1e1-42010a800070/f0845c65c3073e0b7b0b95ce0c1eb27f69d12b1fe2382b50096c4b59e78cdf71/cpu.cfs_quota_us</span></span>
<span class="line"><span style="color:#50fa7b">10000</span></span></code></pre><p>如我所说，这些值与容器配置中指定的值相同。但是这两个属性的值是如何从我们在 Pod 中设置的 100m cpu<code>limits</code>得出的呢，他们是如何实现该<code>limits</code>的呢？</p><p>这是因为 cpu<code>requests</code>和 cpu<code>limits</code>是使用两个独立的控制系统来实现的。Requests 使用的是 cpu<code>shares</code>系统，cpu<code>shares</code>将每个 CPU 核心划分为 1024 个时间片，并保证每个进程将获得固定比例份额的时间片。如果总共有 1024 个时间片，并且两个进程中的每一个都将 cpu.shares 设置为 512，那么它们将分别获得大约一半的 CPU 可用时间。但 cpu<code>shares</code>系统无法精确控制 CPU 使用率的上限，如果一个进程没有设置 shares，则另一个进程可用自由使用 CPU 资源。</p><blockquote><p>大约在 2010 年左右，谷歌团队和其他一部分人注意到了这个问题。为了解决这个问题，后来在 linux 内核中增加了第二个功能更强大的控制系统：CPU 带宽控制组。带宽控制组定义了一个 周期，通常为 1/10 秒（即 100000 微秒）。还定义了一个 配额，表示允许进程在设置的周期长度内所能使用的 CPU 时间数，两个文件配合起来设置 CPU 的使用上限。两个文件的单位都是微秒（us），cfs_period_us 的取值范围为 1 毫秒（ms）到 1 秒（s），cfs_quota_us 的取值大于 1ms 即可，如果 cfs_quota_us 的值为 -1（默认值），表示不受 CPU 时间的限制。</p></blockquote><p>下面是几个例子：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#6272a4"># 1.限制只能使用1个CPU（每250ms能使用250ms的CPU时间）</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">echo</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">250000</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">></span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cpu.cfs_quota_us</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/</span><span style="color:#bd93f9;font-style:italic">*</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">quota</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">=</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">250</span><span style="color:#f1fa8c">ms</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9;font-style:italic">*</span><span style="color:#f1fa8c">/</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">echo</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">250000</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">></span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cpu.cfs_period_us</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/</span><span style="color:#bd93f9;font-style:italic">*</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">period</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">=</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">250</span><span style="color:#f1fa8c">ms</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9;font-style:italic">*</span><span style="color:#f1fa8c">/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6272a4"># 2.限制使用2个CPU（内核）（每500ms能使用1000ms的CPU时间，即使用两个内核）</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">echo</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">1000000</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">></span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cpu.cfs_quota_us</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/</span><span style="color:#bd93f9;font-style:italic">*</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">quota</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">=</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">1000</span><span style="color:#f1fa8c">ms</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9;font-style:italic">*</span><span style="color:#f1fa8c">/</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">echo</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">500000</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">></span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cpu.cfs_period_us</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/</span><span style="color:#bd93f9;font-style:italic">*</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">period</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">=</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">500</span><span style="color:#f1fa8c">ms</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9;font-style:italic">*</span><span style="color:#f1fa8c">/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6272a4"># 3.限制使用1个CPU的20%（每50ms能使用10ms的CPU时间，即使用一个CPU核心的20%）</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">echo</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">10000</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">></span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cpu.cfs_quota_us</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/</span><span style="color:#bd93f9;font-style:italic">*</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">quota</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">=</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">10</span><span style="color:#f1fa8c">ms</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9;font-style:italic">*</span><span style="color:#f1fa8c">/</span></span>
<span class="line"><span style="color:#50fa7b">$</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">echo</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">50000</span><span style="color:#f8f8f2"> </span><span style="color:#ff79c6">></span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">cpu.cfs_period_us</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/</span><span style="color:#bd93f9;font-style:italic">*</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">period</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">=</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9">50</span><span style="color:#f1fa8c">ms</span><span style="color:#f8f8f2"> </span><span style="color:#bd93f9;font-style:italic">*</span><span style="color:#f1fa8c">/</span></span></code></pre><p>在本例中我们将 Pod 的 cpu<code>limits</code>设置为 100m，这表示 100/1000 个 CPU 核心，即 100000 微秒的 CPU 时间周期中的 10000。所以该<code>limits</code>翻译到 cpu,cpuacct cgroup 中被设置为 cpu.cfs_period_us=100000 和 cpu.cfs_quota_us=10000。</p><p>另外其中的 cfs 代表 Completely Fair Scheduler（绝对公平调度），这是 Linux 系统中默认的 CPU 调度算法。还有一个实时调度算法，它也有自己相应的配额值。</p><p>现在让我们来总结一下：</p><ul><li>在 Kubernetes 中设置的 cpu<code>requests</code>最终会被 cgroup 设置为 cpu.shares 属性的值， cpu<code>limits</code>会被带宽控制组设置为 cpu.cfs_period_us 和 cpu.cfs_quota_us 属性的值。与内存一样，cpu<code>requests</code>主要用于在调度时通知调度器节点上至少需要多少个 cpu<code>shares</code>才可以被调度。</li><li>与 内存<code>requests</code>不同，设置了 cpu<code>requests</code>会在 cgroup 中设置一个属性，以确保内核会将该数量的<code>shares</code>分配给进程。</li><li>cpu<code>limits</code>与 内存<code>limits</code>也有所不同。如果容器进程使用的内存资源超过了内存使用限制，那么该进程将会成为 oom-killing 的候选者。但是容器进程基本上永远不能超过设置的 CPU 配额，所以容器永远不会因为尝试使用比分配的更多的 CPU 时间而被驱逐。系统会在调度程序中强制进行 CPU 资源限制，以确保进程不会超过这个限制。</li></ul><p>如果你没有在容器中设置这些属性，或将他们设置为不准确的值，会发生什么呢？与内存一样，如果只设置了<code>limits</code>而没有设置<code>requests</code>，Kubernetes 会将 CPU 的<code>requests</code>设置为 与<code>limits</code>的值一样。</p><p>如果只设置了 CPU<code>requests</code>却没有设置 CPU<code>limits</code>会怎么样呢？这种情况下，Kubernetes 会确保该 Pod 被调度到合适的节点，并且该节点的内核会确保节点上的可用 cpu<code>shares</code>大于 Pod 请求的 cpu shares，但是你的进程不会被阻止使用超过所请求的 CPU 数量。既不设置<code>requests</code>也不设置<code>limits</code>是最糟糕的情况：调度程序不知道容器需要什么，并且进程对 cpu<code>shares</code>的使用是无限制的，这可能会对 node 产生一些负面影响。</p><p>最后我还想告诉你们的是：为每个 pod 都手动配置这些参数是挺麻烦的事情，kubernetes 提供了 LimitRange 资源，可以让我们配置某个 namespace 默认的 request 和 limit 值。</p><h2 id="默认限制">默认限制</h2><p>通过上文的讨论大家已经知道了忽略资源限制会对 Pod 产生负面影响，因此你可能会想，如果能够配置某个 namespace 默认的 request 和 limit 值就好了，这样每次创建新 Pod 都会默认加上这些限制。Kubernetes 允许我们通过 LimitRange 资源对每个命名空间设置资源限制。</p><p>要创建默认的资源限制，需要在对应的命名空间中创建一个 LimitRange 资源。下面是一个例子：</p><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#8be9fd">apiVersion</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">v1</span></span>
<span class="line"><span style="color:#8be9fd">kind</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">LimitRange</span></span>
<span class="line"><span style="color:#8be9fd">metadata</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#8be9fd">name</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">default-limit</span></span>
<span class="line"><span style="color:#8be9fd">spec</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#8be9fd">limits</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#ff79c6">-</span><span style="color:#f8f8f2"> </span><span style="color:#8be9fd">default</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">memory</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">100Mi</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">cpu</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">100m</span></span>
<span class="line"><span style="color:#f8f8f2">      </span><span style="color:#8be9fd">defaultRequest</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">memory</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">50Mi</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">cpu</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">50m</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#ff79c6">-</span><span style="color:#f8f8f2"> </span><span style="color:#8be9fd">max</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">memory</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">512Mi</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">cpu</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">500m</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#ff79c6">-</span><span style="color:#f8f8f2"> </span><span style="color:#8be9fd">min</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">memory</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">50Mi</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">cpu</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">50m</span></span>
<span class="line"><span style="color:#f8f8f2">      </span><span style="color:#8be9fd">type</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">Container</span></span></code></pre><p>这里的几个字段可能会让你们有些困惑，我拆开来给你们分析一下。</p><p>-<code>limits</code>字段下面的 default 字段表示每个 Pod 的默认的<code>limits</code>配置，所以任何没有分配资源的<code>limits</code>的 Pod 都会被自动分配 100Mi<code>limits</code>的内存和 100m<code>limits</code>的 CPU。</p><ul><li>defaultRequest 字段表示每个 Pod 的默认<code>requests</code>配置，所以任何没有分配资源的<code>requests</code>的 Pod 都会被自动分配 50Mi<code>requests</code>的内存和 50m<code>requests</code>的 CPU。</li><li>max 和 min 字段比较特殊，如果设置了这两个字段，那么只要这个命名空间中的 Pod 设置的<code>limits</code>和<code>requests</code>超过了这个上限和下限，就不会允许这个 Pod 被创建。我暂时还没有发现这两个字段的用途，如果你知道，欢迎在留言告诉我。</li><li>LimitRange 中设定的默认值最后由 Kubernetes 中的准入控制器 LimitRanger 插件来实现。准入控制器由一系列插件组成，它会在 API 接收对象之后创建 Pod 之前对 Pod 的 Spec - 字段进行修改。对于 LimitRanger 插件来说，它会检查每个 Pod 是否设置了<code>limits</code>和 requests，如果没有设置，就给它配置 LimitRange 中设定的默认值。通过检查 Pod 中的 annotations 注释，你可以看到 LimitRanger 插件已经在你的 Pod 中设置了默认值。例如：</li></ul><pre class="astro-code dracula" is:raw="" style="background-color:#282a36;overflow-x:auto" tabindex="0"><code><span class="line"><span style="color:#8be9fd">apiVersion</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">v1</span></span>
<span class="line"><span style="color:#8be9fd">kind</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">Pod</span></span>
<span class="line"><span style="color:#8be9fd">metadata</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#8be9fd">annotations</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#8be9fd">kubernetes.io/limit-ranger</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#e9f284">'</span><span style="color:#f1fa8c">LimitRanger plugin set: cpu request for container</span></span>
<span class="line"><span style="color:#f1fa8c">      limit-test</span><span style="color:#e9f284">'</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#8be9fd">name</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">limit-test-859d78bc65-g6657</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#8be9fd">namespace</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">default</span></span>
<span class="line"><span style="color:#8be9fd">spec</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">  </span><span style="color:#8be9fd">containers</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">    </span><span style="color:#ff79c6">-</span><span style="color:#f8f8f2"> </span><span style="color:#8be9fd">args</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#ff79c6">-</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">/bin/sh</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#ff79c6">-</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">-c</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#ff79c6">-</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">while true; do sleep 2; done</span></span>
<span class="line"><span style="color:#f8f8f2">      </span><span style="color:#8be9fd">image</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">busybox</span></span>
<span class="line"><span style="color:#f8f8f2">      </span><span style="color:#8be9fd">imagePullPolicy</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">Always</span></span>
<span class="line"><span style="color:#f8f8f2">      </span><span style="color:#8be9fd">name</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">limit-test</span></span>
<span class="line"><span style="color:#f8f8f2">      </span><span style="color:#8be9fd">resources</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">        </span><span style="color:#8be9fd">requests</span><span style="color:#ff79c6">:</span></span>
<span class="line"><span style="color:#f8f8f2">          </span><span style="color:#8be9fd">cpu</span><span style="color:#ff79c6">:</span><span style="color:#f8f8f2"> </span><span style="color:#f1fa8c">100m</span></span></code></pre><p>以上就是我对 Kubernetes 资源限制的全部见解，希望能对你有所帮助。如果你想了解更多关于 Kubernetes 中资源的<code>limits</code>和 requests、以及 linux cgroup 和内存管理的更多详细信息，可以查看我在文末提供的参考链接。</p><h2 id="参考文档">参考文档</h2><ul><li><a href="https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-cpu-time-9eff74d3161b">https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-cpu-time-9eff74d3161b</a></li><li><a href="https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-memory-6b41e9a955f9">https://medium.com/@betz.mark/understanding-resource-limits-in-kubernetes-memory-6b41e9a955f9</a></li></ul></div></div><div class="flex flex-col justify-between max-w-3xl mx-auto sm:flex-row sm:px-6 mt-8 px-6"><ul class="mr-5"><li class="border border-slate-500 dark:border-slate-100 font-medium inline-block mx-1 my-1 px-2 py-1 rounded-full"><a href="/tags/k8s" class="dark:text-slate-300 dark:hover:text-blue-400 hover:text-primary text-muted">#k8s</a></li><li class="border border-slate-500 dark:border-slate-100 font-medium inline-block mx-1 my-1 px-2 py-1 rounded-full"><a href="/tags/docker" class="dark:text-slate-300 dark:hover:text-blue-400 hover:text-primary text-muted">#docker</a></li><li class="border border-slate-500 dark:border-slate-100 font-medium inline-block mx-1 my-1 px-2 py-1 rounded-full"><a href="/tags/cgroup" class="dark:text-slate-300 dark:hover:text-blue-400 hover:text-primary text-muted">#cgroup</a></li></ul></div></article><div class="max-w-3xl mx-auto sm:px-6 px-6 dark:text-slate-400 giscus-container py-16 text-muted"><script src="https://giscus.app/client.js" async crossorigin="anonymous" data-category="Announcements" data-category-id="DIC_kwDOCg97r84CBQfL" data-emit-metadata="0" data-input-position="top" data-lang="en" data-mapping="title" data-reactions-enabled="1" data-repo="qingwave/qingwave.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxNjg3ODY4NjM=" data-strict="0" data-theme="light"></script></div></section></main><footer class="relative"><div class="max-w-3xl mx-auto sm:px-6 px-4"><div class="border-t border-gray-200 dark:border-slate-800"></div></div><div class="dark:bg-dark absolute inset-0 pointer-events-none" aria-hidden="true"></div><div class="max-w-3xl mx-auto sm:px-6 px-4 dark:text-slate-300 relative"><div class="md:flex md:justify-between md:items-center md:py-8 py-6"><ul class="md:flex hidden -ml-2 mb-4 md:mb-0 md:ml-4 md:order-1"><li><a href="/rss.xml" class="items-center dark:text-gray-400 inline-flex p-2.5 text-sm text-muted" aria-label="RSS"><svg astro-icon="tabler:rss" class="h-5 w-5" viewBox="0 0 24 24"><g class="icon-tabler" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0 1 16 16M4 11a9 9 0 0 1 9 9"/></g></svg></a></li></ul><div class="text-sm dark:text-slate-400 mr-4"><span class="h-5 w-5 bg-[url(/favicon.ico)] bg-cover float-left md:-mt-0.5 mr-1.5 rounded-sm"></span> <span class="dark:text-slate-300 text-slate-700"><a href="https://qingwave.github.io" class="hover:brightness-50">Qingwave</a> · All rights reserved.</span></div></div></div></footer><script>!function(){const e="light";function t(e){"dark"===e?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")}function o(e,t,o){const n="string"==typeof e?document.querySelectorAll(e):e;n&&n.length&&n.forEach((e=>{e.addEventListener(t,(t=>o(t,e)),!1)}))}e&&e.endsWith(":only")||!localStorage.theme?t(e.replace(":only","")):"dark"===localStorage.theme||!("theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?t("dark"):t("light"),window.onload=function(){let t=window.scrollY,n=!0;function c(){const e=document.getElementById("header");t>60&&!e.classList.contains("scroll")?document.getElementById("header").classList.add("scroll"):t<=60&&e.classList.contains("scroll")&&document.getElementById("header").classList.remove("scroll"),n=!1}o("[data-aw-toggle-menu]","click",(function(e,t){t.classList.toggle("expanded"),document.body.classList.toggle("overflow-hidden"),document.getElementById("header")?.classList.toggle("h-screen"),document.querySelector("#header nav")?.classList.toggle("hidden")})),o("[data-aw-toggle-color-scheme]","click",(function(){e.endsWith(":only")||(document.documentElement.classList.toggle("dark"),localStorage.theme=document.documentElement.classList.contains("dark")?"dark":"light",function(e){const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}({setConfig:{theme:localStorage.theme}}))})),o("[data-aw-social-share]","click",(function(e,t){const o=t.getAttribute("data-aw-social-share"),n=encodeURIComponent(t.getAttribute("data-aw-url")),c=encodeURIComponent(t.getAttribute("data-aw-text"));let a;switch(o){case"facebook":a=`https://www.facebook.com/sharer.php?u=${n}`;break;case"twitter":a=`https://twitter.com/intent/tweet?url=${n}&text=${c}`;break;case"linkedin":a=`https://www.linkedin.com/shareArticle?mini=true&url=${n}&title=${c}`;break;case"whatsapp":a=`https://wa.me/?text=${c}%20${n}`;break;case"mail":a=`mailto:?subject=%22${c}%22&body=${c}%20${n}`;break;default:return}const s=document.createElement("a");s.target="_blank",s.href=a,s.click()})),c(),o([document],"scroll",(function(){t=window.scrollY,n||(window.requestAnimationFrame((()=>{c()})),n=!0)}))},window.onpageshow=function(){document.documentElement.classList.add("motion-safe:scroll-smooth");const e=document.querySelector("[data-aw-toggle-menu]");e&&e.classList.remove("expanded"),document.body.classList.remove("overflow-hidden"),document.getElementById("header")?.classList.remove("h-screen"),document.querySelector("#header nav")?.classList.add("hidden")}}()</script></body></html>