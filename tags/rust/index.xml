<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>rust - 标签 - Qingwave</title>
        <link>https://qingwave.github.io/tags/rust/</link>
        <description>rust - 标签 - Qingwave</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>isguory@gmail.com (Qingwave)</managingEditor>
            <webMaster>isguory@gmail.com (Qingwave)</webMaster><lastBuildDate>Thu, 24 Nov 2022 16:50:14 &#43;0800</lastBuildDate><atom:link href="https://qingwave.github.io/tags/rust/" rel="self" type="application/rss+xml" /><item>
    <title>Rust初探: 实现一个Ping</title>
    <link>https://qingwave.github.io/rust-ping/</link>
    <pubDate>Thu, 24 Nov 2022 16:50:14 &#43;0800</pubDate><author>
        <name>Qingwave</name>
    </author><guid>https://qingwave.github.io/rust-ping/</guid>
    <description><![CDATA[<p>这两年Rust火的一塌糊涂，甚至都烧到了前端，再不学习怕是要落伍了。最近翻了翻文档，写了个简单的Ping应用练练手，被所有权折腾的够呛，相比起Golang上手难度大很多，现将开发中的一些问题总结如下，所有源码见<a href="https://github.com/qingwave/ring" target="_blank" rel="noopener noreffer">ring</a>。</p>
<h2 id="目标" class="headerLink">
    <a href="#%e7%9b%ae%e6%a0%87" class="header-mark"></a>目标</h2><p>实现一个Ping，功能包含：</p>
<ul>
<li>命令行解析</li>
<li>实现ICMP协议，<a href="https://docs.rs/pnet/latest/pnet/" target="_blank" rel="noopener noreffer">pnet</a>包中已经包含了ICMP包定义，可以使用<a href="https://docs.rs/socket2/latest/socket2/" target="_blank" rel="noopener noreffer">socket2</a>库发送</li>
<li>周期性发送Ping，通过多线程发送，再汇总结果</li>
<li>监听退出信号</li>
</ul>
<h3 id="命令行解析" class="headerLink">
    <a href="#%e5%91%bd%e4%bb%a4%e8%a1%8c%e8%a7%a3%e6%9e%90" class="header-mark"></a>命令行解析</h3><p>系统库<code>std::env::args</code>可以解析命令行参数，但对于一些复杂的参数使用起来比较繁琐，更推荐<a href="https://docs.rs/crate/clap/latest" target="_blank" rel="noopener noreffer">clap</a>。利用clap的注解，通过结构体定义命令行参数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="sd">/// ping but with rust, rust + ping -&gt; ring
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="cp">#[derive(Parser, Debug, Clone)]</span><span class="w"> </span><span class="c1">// Parser生成clap命令行解析方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#[command(author, version, about, long_about = None)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Args</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// Count of ping times
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="cp">#[arg(short, default_value_t = 4)]</span><span class="w"> </span><span class="c1">// short表示开启短命名，默认为第一个字母，可以指定；default_value_t设置默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">count</span>: <span class="kt">u16</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// Ping packet size
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="cp">#[arg(short = &#39;s&#39;, default_value_t = 64)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">packet_size</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// Ping ttl
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="cp">#[arg(short = &#39;t&#39;, default_value_t = 64)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ttl</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// Ping timeout seconds
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="cp">#[arg(short = &#39;w&#39;, default_value_t = 1)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">timeout</span>: <span class="kt">u64</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// Ping interval duration milliseconds
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="cp">#[arg(short = &#39;i&#39;, default_value_t = 1000)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">interval</span>: <span class="kt">u64</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// Ping destination, ip or domain
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="cp">#[arg(value_parser=Address::parse)]</span><span class="w"> </span><span class="c1">// 自定义解析
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">destination</span>: <span class="nc">Address</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>clap可以方便的指定参数命名、默认值、解析方法等，运行结果如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">➜  ring git:<span class="o">(</span>main<span class="o">)</span> cargo run -- -h
</span></span><span class="line"><span class="cl">   Compiling ring v0.1.0 <span class="o">(</span>/home/i551329/work/ring<span class="o">)</span>
</span></span><span class="line"><span class="cl">    Finished dev <span class="o">[</span>unoptimized + debuginfo<span class="o">]</span> target<span class="o">(</span>s<span class="o">)</span> in 1.72s
</span></span><span class="line"><span class="cl">     Running <span class="sb">`</span>target/debug/ring -h<span class="sb">`</span>
</span></span><span class="line"><span class="cl">ping but with rust, rust + ping -&gt; ring
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Usage: ring <span class="o">[</span>OPTIONS<span class="o">]</span> &lt;DESTINATION&gt;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Arguments:
</span></span><span class="line"><span class="cl">  &lt;DESTINATION&gt;  Ping destination, ip or domain
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Options:
</span></span><span class="line"><span class="cl">  -c &lt;COUNT&gt;            Count of ping <span class="nb">times</span> <span class="o">[</span>default: 4<span class="o">]</span>
</span></span><span class="line"><span class="cl">  -s &lt;PACKET_SIZE&gt;      Ping packet size <span class="o">[</span>default: 64<span class="o">]</span>
</span></span><span class="line"><span class="cl">  -t &lt;TTL&gt;              Ping ttl <span class="o">[</span>default: 64<span class="o">]</span>
</span></span><span class="line"><span class="cl">  -w &lt;TIMEOUT&gt;          Ping timeout seconds <span class="o">[</span>default: 1<span class="o">]</span>
</span></span><span class="line"><span class="cl">  -i &lt;INTERVAL&gt;         Ping interval duration milliseconds <span class="o">[</span>default: 1000<span class="o">]</span>
</span></span><span class="line"><span class="cl">  -h, --help            Print <span class="nb">help</span> information
</span></span><span class="line"><span class="cl">  -V, --version         Print version information
</span></span></code></pre></div><h3 id="实现ping" class="headerLink">
    <a href="#%e5%ae%9e%e7%8e%b0ping" class="header-mark"></a>实现Ping</h3><p>pnet中提供了ICMP包的定义，socket2可以将定义好的ICMP包发送给目标IP，另一种实现是通过<code>pnet_transport::transport_channel</code>发送原始数据包，但需要过滤结果而且权限要求较高。</p>
<p>首先定义ICMP包</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">packet_size</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">icmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MutableEchoRequestPacket</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="o">..</span><span class="p">]).</span><span class="n">ok_or</span><span class="p">(</span><span class="n">RingError</span>::<span class="n">InvalidBufferSize</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">icmp</span><span class="p">.</span><span class="n">set_icmp_type</span><span class="p">(</span><span class="n">IcmpTypes</span>::<span class="n">EchoRequest</span><span class="p">);</span><span class="w"> </span><span class="c1">// 设置为EchoRequest类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">icmp</span><span class="p">.</span><span class="n">set_icmp_code</span><span class="p">(</span><span class="n">IcmpCodes</span>::<span class="n">NoCode</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">icmp</span><span class="p">.</span><span class="n">set_sequence_number</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">sequence</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">seq_offset</span><span class="p">);</span><span class="w"> </span><span class="c1">// 序列号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">icmp</span><span class="p">.</span><span class="n">set_identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">id</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">icmp</span><span class="p">.</span><span class="n">set_checksum</span><span class="p">(</span><span class="n">util</span>::<span class="n">checksum</span><span class="p">(</span><span class="n">icmp</span><span class="p">.</span><span class="n">packet</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"> </span><span class="c1">// 校验函数
</span></span></span></code></pre></div><p>通过socket2发送请求</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Socket</span>::<span class="n">new</span><span class="p">(</span><span class="n">Domain</span>::<span class="no">IPV4</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span>::<span class="no">DGRAM</span><span class="p">,</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">Protocol</span>::<span class="no">ICMPV4</span><span class="p">))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SocketAddr</span>::<span class="n">new</span><span class="p">(</span><span class="n">net</span>::<span class="n">IpAddr</span>::<span class="n">V4</span><span class="p">(</span><span class="n">Ipv4Addr</span>::<span class="no">UNSPECIFIED</span><span class="p">),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">socket</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="p">.</span><span class="n">into</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// 绑定源地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">socket</span><span class="p">.</span><span class="n">set_ttl</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">ttl</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">socket</span><span class="p">.</span><span class="n">set_read_timeout</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">timeout</span><span class="p">)))</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// 超时配置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">socket</span><span class="p">.</span><span class="n">set_write_timeout</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_secs</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">timeout</span><span class="p">)))</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 发送
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">socket</span><span class="p">.</span><span class="n">send_to</span><span class="p">(</span><span class="n">icmp</span><span class="p">.</span><span class="n">packet_mut</span><span class="p">(),</span><span class="w"> </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="n">dest</span><span class="p">.</span><span class="n">into</span><span class="p">())</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>最后处理相应，转换成pnet中的EchoReplyPacket</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">mem_buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="n">buf</span><span class="p">.</span><span class="n">as_mut_slice</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">*</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">])</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">socket</span><span class="p">.</span><span class="n">recv_from</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">mem_buf</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 转换成EchoReply
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">reply</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EchoReplyPacket</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">).</span><span class="n">ok_or</span><span class="p">(</span><span class="n">RingError</span>::<span class="n">InvalidPacket</span><span class="p">)</span><span class="o">?</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>至此，一次Ping请求完成。</p>
<h3 id="周期性发送" class="headerLink">
    <a href="#%e5%91%a8%e6%9c%9f%e6%80%a7%e5%8f%91%e9%80%81" class="header-mark"></a>周期性发送</h3><p>Ping需要周期性的发送请求，比如秒秒请求一次，如果直接通过循环实现，一次请求卡住将影响主流程，必须通过多线程来保证固定周期的发送。</p>
<p>发送请求</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">send</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">AtomicU64</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"> </span><span class="c1">// 统计发送次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">_send</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">send</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">sx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounded</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w"> </span><span class="c1">// channel接受线程handler
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">this</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">_this</span><span class="p">.</span><span class="n">ping</span><span class="p">(</span><span class="n">i</span><span class="p">))).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="c1">// 线程中运行ping，并将handler发送到channel中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">_send</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w"> </span><span class="c1">// 发送一次，send加1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">thread</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="n">this</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">interval</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">drop</span><span class="p">(</span><span class="n">sx</span><span class="p">);</span><span class="w"> </span><span class="c1">// 发送完成关闭channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span><span class="w">
</span></span></span></code></pre></div><ul>
<li><code>thread::spawn</code>可以快速创建线程，但需要注意所有权的转移，如果在线程内部调用方法获取变量，需要通过<code>Arc</code>原子引用计数</li>
<li><code>send</code>变量用来统计发送数，原子类型，并且用Arc包裹；<code>this</code>是当前类的Arc克隆，会转移到线程中</li>
<li>第一个线程内周期性调用<code>ping()</code>，并且其在单独线程中运行</li>
<li>通过<code>bounded</code>来定义channel(类似Golang中的chan)，用来处理结果，发送完成关闭</li>
</ul>
<p>处理结果</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Arc</span>::<span class="n">new</span><span class="p">(</span><span class="n">AtomicU64</span>::<span class="n">new</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span><span class="w"> </span><span class="c1">// 定义请求成功的请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">_success</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">success</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">summary_s</span><span class="p">,</span><span class="w"> </span><span class="n">summary_r</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounded</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// channel来判断是否处理完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">rx</span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handle</span><span class="p">.</span><span class="n">join</span><span class="p">().</span><span class="n">ok</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">res</span><span class="p">.</span><span class="n">is_ok</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">_success</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span>::<span class="n">SeqCst</span><span class="p">);</span><span class="w"> </span><span class="c1">// 如果handler结果正常，success加1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">summary_s</span><span class="p">.</span><span class="n">send</span><span class="p">(()).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"> </span><span class="c1">// 处理完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">});</span><span class="w">
</span></span></span></code></pre></div><p>第二个线程用来统计结果，channel通道取出ping线程的handler，如果返回正常则加1</p>
<p>处理信号</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">stop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">signal_notify</span><span class="p">()</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// 监听退出信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="fm">select!</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">recv</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">sig</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sig</span><span class="p">.</span><span class="n">ok</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 收到退出信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Receive signal </span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">recv</span><span class="p">(</span><span class="n">summary_r</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">summary</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 任务完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">summary</span><span class="p">.</span><span class="n">err</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Error on summary: </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div><p>通过select来处理信号(类似Golang中的select)，到收到退出信号或者任务完成时继续往下执行。</p>
<h3 id="信号处理" class="headerLink">
    <a href="#%e4%bf%a1%e5%8f%b7%e5%a4%84%e7%90%86" class="header-mark"></a>信号处理</h3><p>Golang中可以很方便的处理信号，但在Rust中官方库没有提供类似功能，可以通过<code>signal_hook</code>与<code>crossbeam_channel</code>实现监听退出信号</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">signal_notify</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">std</span>::<span class="n">io</span>::<span class="nb">Result</span><span class="o">&lt;</span><span class="n">Receiver</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bounded</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 定义channel，用来异步接受退出信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">signals</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">signal_hook</span>::<span class="n">iterator</span>::<span class="n">Signals</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="no">SIGINT</span><span class="p">,</span><span class="w"> </span><span class="no">SIGTERM</span><span class="p">])</span><span class="o">?</span><span class="p">;</span><span class="w"> </span><span class="c1">// 创建信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">thread</span>::<span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">signal</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">signals</span><span class="p">.</span><span class="n">forever</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 如果结果到信号发送到channel中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">            </span><span class="n">s</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">signal</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="c1">// 返回接受channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="其他" class="headerLink">
    <a href="#%e5%85%b6%e4%bb%96" class="header-mark"></a>其他</h3><p>很多吐槽人Golang的错误处理，Rust也不遑多让，不过提供了<code>?</code>语法糖，也可以配合<code>anyhow</code>与<code>thiserror</code>来简化错误处理。</p>
<h2 id="验证" class="headerLink">
    <a href="#%e9%aa%8c%e8%af%81" class="header-mark"></a>验证</h2><p>Ping域名/IP</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ring git:<span class="o">(</span>main<span class="o">)</span>  cargo run -- www.baidu.com 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PING www.baidu.com<span class="o">(</span>103.235.46.40<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="m">64</span> bytes from 103.235.46.40: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>255.85ms
</span></span><span class="line"><span class="cl"><span class="m">64</span> bytes from 103.235.46.40: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">2</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>254.17ms
</span></span><span class="line"><span class="cl"><span class="m">64</span> bytes from 103.235.46.40: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">3</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>255.41ms
</span></span><span class="line"><span class="cl"><span class="m">64</span> bytes from 103.235.46.40: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">4</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>256.50ms
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--- www.baidu.com ping statistics ---
</span></span><span class="line"><span class="cl"><span class="m">4</span> packets transmitted, <span class="m">4</span> received, 0% packet loss, <span class="nb">time</span> 3257.921ms
</span></span></code></pre></div><p>测试退出信息，运行中通过Ctrl+C中止</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cargo run 8.8.8.8 -c <span class="m">10</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">PING 8.8.8.8<span class="o">(</span>8.8.8.8<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="m">64</span> bytes from 8.8.8.8: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>4.32ms
</span></span><span class="line"><span class="cl"><span class="m">64</span> bytes from 8.8.8.8: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">2</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>3.02ms
</span></span><span class="line"><span class="cl"><span class="m">64</span> bytes from 8.8.8.8: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">3</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>3.24ms
</span></span><span class="line"><span class="cl">^CReceive signal <span class="m">2</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--- 8.8.8.8 ping statistics ---
</span></span><span class="line"><span class="cl"><span class="m">3</span> packets transmitted, <span class="m">3</span> received, 0% packet loss, <span class="nb">time</span> 2365.104ms
</span></span></code></pre></div><h2 id="总结" class="headerLink">
    <a href="#%e6%80%bb%e7%bb%93" class="header-mark"></a>总结</h2><p>Rust为了安全高效，通过引入所有权来解决GC问题，也带来了许多不便，编程时必须要考虑到变量的声明周期、借用等问题，所有语言都是在方便、性能、安全之间做权衡，要么程序员不方便，要么编译器多做点功。换一个角度来说Bug总是不可避免的，在编译阶段出现总好过运行阶段。</p>
<p>所有源码见: <a href="https://github.com/qingwave/ring" target="_blank" rel="noopener noreffer">https://github.com/qingwave/ring</a></p>
<blockquote>
<p>Explore more in <a href="https://qingwave.github.io" target="_blank" rel="noopener noreffer">https://qingwave.github.io</a></p>
</blockquote>
]]></description>
</item></channel>
</rss>
